At line no: 1 	type_specifier: INT

int 

At line no: 1 	type_specifier: FLOAT

float 

At line no: 1 	parameter_list: type_specifier ID

float x 

At line no: 2 	variable: ID

x 

At line no: 2 	factor: variable

x 

At line no: 2 	unary_expression: factor

x 

At line no: 2 	term: unary_expression

x 

At line no: 2 	simple_expression: term

x 

At line no: 2 	factor: CONST_INT

0 

At line no: 2 	unary_expression: factor

0 

At line no: 2 	term: unary_expression

0 

At line no: 2 	simple_expression: term

0 

At line no: 2 	rel_expression: simple_expression

x < 0 

At line no: 2 	logic_expression: rel_expression

x < 0 

At line no: 2 	expression: logic_expression

x < 0 

At line no: 2 	variable: ID

x 

At line no: 2 	factor: variable

x 

At line no: 2 	unary_expression: factor

x 

At line no: 2 	unary_expression: ADDOP unary_expression

- x 

At line no: 2 	term: unary_expression

- x 

At line no: 2 	simple_expression: term

- x 

At line no: 2 	rel_expression: simple_expression

- x 

At line no: 2 	logic_expression: rel_expression

- x 

At line no: 2 	expression: logic_expression

- x 

At line no: 2 	statement: RETURN expression SEMICOLON

return - x ; 


At line no: 3 	statement: IF LPAREN expression RPAREN statement

if ( x < 0 ) return - x ; 


At line no: 3 	statements: statement

if ( x < 0 ) return - x ; 


At line no: 3 	variable: ID

x 

At line no: 3 	factor: variable

x 

At line no: 3 	unary_expression: factor

x 

At line no: 3 	term: unary_expression

x 

At line no: 3 	simple_expression: term

x 

At line no: 3 	rel_expression: simple_expression

x 

At line no: 3 	logic_expression: rel_expression

x 

At line no: 3 	expression: logic_expression

x 

At line no: 3 	statement: RETURN expression SEMICOLON

return x ; 


At line no: 3 	statements: statements statement

if ( x < 0 ) return - x ; 
return x ; 


 ScopeTable # 1
 1 --> < x : ID >

At line no: 4 	compound_statement: LCURL statements RCURL

{ 
  if ( x < 0 ) return - x ; 
  return x ; 
} 


At line no: 4 	func_definition: type_specifier ID LPAREN parameter_list RPAREN compound_statement

int bar ( float x ) { 
  if ( x < 0 ) return - x ; 
  return x ; 
} 


At line no: 4 	unit: func_definition

int bar ( float x ) { 
  if ( x < 0 ) return - x ; 
  return x ; 
} 


At line no: 4 	program: unit

int bar ( float x ) { 
  if ( x < 0 ) return - x ; 
  return x ; 
} 


At line no: 6 	type_specifier: VOID

void 

At line no: 7 	variable: ID

bar 

At line no: 7 	factor: variable

bar 

At line no: 7 	unary_expression: factor

bar 

At line no: 7 	term: unary_expression

bar 

At line no: 7 	simple_expression: term

bar 

At line no: 7 	rel_expression: simple_expression

bar 

At line no: 7 	logic_expression: rel_expression

bar 

At line no: 7 	expression: logic_expression

bar 

At line no: 7 	statement: RETURN expression SEMICOLON

return bar ; 


At line no: 7 	statements: statement

return bar ; 


 ScopeTable # 1

At line no: 8 	compound_statement: LCURL statements RCURL

{ 
  return bar ; 
} 


At line no: 8 	func_definition: type_specifier ID LPAREN RPAREN compound_statement

void foo ( ) { 
  return bar ; 
} 


At line no: 8 	unit: func_definition

void foo ( ) { 
  return bar ; 
} 


At line no: 8 	program: program unit

int bar ( float x ) { 
  if ( x < 0 ) return - x ; 
  return x ; 
} 
void foo ( ) { 
  return bar ; 
} 


At line no: 12 	type_specifier: INT

int 

At line no: 13 	factor: CONST_INT

0 

At line no: 13 	unary_expression: factor

0 

At line no: 13 	term: unary_expression

0 

At line no: 13 	simple_expression: term

0 

At line no: 13 	rel_expression: simple_expression

0 

At line no: 13 	logic_expression: rel_expression

0 

At line no: 13 	expression: logic_expression

0 

At line no: 13 	statement: RETURN expression SEMICOLON

return 0 ; 


At line no: 13 	statements: statement

return 0 ; 


 ScopeTable # 1

At line no: 14 	compound_statement: LCURL statements RCURL

{ 
  return 0 ; 
} 


At line no: 14 	func_definition: type_specifier ID LPAREN RPAREN compound_statement

int oops ( ) { 
  return 0 ; 
} 


At line no: 14 	unit: func_definition

int oops ( ) { 
  return 0 ; 
} 


At line no: 14 	program: program unit

int bar ( float x ) { 
  if ( x < 0 ) return - x ; 
  return x ; 
} 
void foo ( ) { 
  return bar ; 
} 
int oops ( ) { 
  return 0 ; 
} 


At line no: 16 	type_specifier: INT

int 

At line no: 16 	type_specifier: INT

int 

At line no: 16 	parameter_list: type_specifier ID

int pos 

At line no: 17 	type_specifier: INT

int 

At line no: 17 	declaration_list: ID

pos 

At line no: 17 	var_declaration: type_specifier declaration_list SEMICOLON

int pos ; 


At line no: 17 	statement: var_declaration

int pos ; 


At line no: 17 	statements: statement

int pos ; 


At line no: 18 	variable: ID

pos 

At line no: 18 	factor: CONST_INT

5 

At line no: 18 	unary_expression: factor

5 

At line no: 18 	term: unary_expression

5 

At line no: 18 	simple_expression: term

5 

At line no: 18 	rel_expression: simple_expression

5 

At line no: 18 	logic_expression: rel_expression

5 

At line no: 18 	expression: variable ASSIGNOP logic_expression

pos = 5 

At line no: 18 	expression_statement: expression SEMICOLON

pos = 5 ; 


At line no: 18 	statement: expression_statement

pos = 5 ; 


At line no: 18 	statements: statements statement

int pos ; 
pos = 5 ; 


At line no: 19 	variable: ID

oops 

At line no: 19 	variable: ID

pos 

At line no: 19 	factor: variable

pos 

At line no: 19 	unary_expression: factor

pos 

At line no: 19 	term: unary_expression

pos 

At line no: 19 	factor: CONST_INT

9 

At line no: 19 	unary_expression: factor

9 

At line no: 19 	term: term MULOP unary_expression

pos * 9 

At line no: 19 	simple_expression: term

pos * 9 

At line no: 19 	factor: CONST_FLOAT

2.5 

At line no: 19 	unary_expression: factor

2.5 

At line no: 19 	term: unary_expression

2.5 

At line no: 19 	simple_expression: simple_expression ADDOP term

pos * 9 + 2.5 

At line no: 19 	rel_expression: simple_expression

pos * 9 + 2.5 

At line no: 19 	logic_expression: rel_expression

pos * 9 + 2.5 

At line no: 19 	expression: variable ASSIGNOP logic_expression

oops = pos * 9 + 2.5 

At line no: 19 	expression_statement: expression SEMICOLON

oops = pos * 9 + 2.5 ; 


At line no: 19 	statement: expression_statement

oops = pos * 9 + 2.5 ; 


At line no: 19 	statements: statements statement

int pos ; 
pos = 5 ; 
oops = pos * 9 + 2.5 ; 


 ScopeTable # 1
 2 --> < pos : ID >

At line no: 20 	compound_statement: LCURL statements RCURL

{ 
  int pos ; 
  pos = 5 ; 
  oops = pos * 9 + 2.5 ; 
} 


At line no: 20 	func_definition: type_specifier ID LPAREN parameter_list RPAREN compound_statement

int oops ( int pos ) { 
  int pos ; 
  pos = 5 ; 
  oops = pos * 9 + 2.5 ; 
} 


At line no: 20 	unit: func_definition

int oops ( int pos ) { 
  int pos ; 
  pos = 5 ; 
  oops = pos * 9 + 2.5 ; 
} 


At line no: 20 	program: program unit

int bar ( float x ) { 
  if ( x < 0 ) return - x ; 
  return x ; 
} 
void foo ( ) { 
  return bar ; 
} 
int oops ( ) { 
  return 0 ; 
} 
int oops ( int pos ) { 
  int pos ; 
  pos = 5 ; 
  oops = pos * 9 + 2.5 ; 
} 


At line no: 22 	type_specifier: INT

int 

At line no: 22 	type_specifier: INT

int 

At line no: 22 	parameter_list: type_specifier

int 

At line no: 22 	type_specifier: FLOAT

float 

At line no: 22 	parameter_list: parameter_list COMMA type_specifier

int , float 

At line no: 22 	type_specifier: INT

int 

At line no: 22 	parameter_list: parameter_list COMMA type_specifier

int , float , int 

At line no: 22 	func_declaration: type_specifier ID LPAREN parameter_list RPAREN SEMICOLON

int func ( int , float , int ) ; 


At line no: 22 	unit: func_declaration

int func ( int , float , int ) ; 


At line no: 22 	program: program unit

int bar ( float x ) { 
  if ( x < 0 ) return - x ; 
  return x ; 
} 
void foo ( ) { 
  return bar ; 
} 
int oops ( ) { 
  return 0 ; 
} 
int oops ( int pos ) { 
  int pos ; 
  pos = 5 ; 
  oops = pos * 9 + 2.5 ; 
} 
int func ( int , float , int ) ; 


At line no: 24 	type_specifier: INT

int 

At line no: 24 	type_specifier: INT

int 

At line no: 24 	parameter_list: type_specifier ID

int a 

At line no: 24 	type_specifier: INT

int 

At line no: 24 	parameter_list: parameter_list COMMA type_specifier ID

int a , int b 

At line no: 24 	type_specifier: INT

int 

At line no: 24 	parameter_list: parameter_list COMMA type_specifier ID

int a , int b , int c 

At line no: 25 	variable: ID

a 

At line no: 25 	factor: variable

a 

At line no: 25 	unary_expression: factor

a 

At line no: 25 	term: unary_expression

a 

At line no: 25 	simple_expression: term

a 

At line no: 25 	variable: ID

b 

At line no: 25 	factor: variable

b 

At line no: 25 	unary_expression: factor

b 

At line no: 25 	term: unary_expression

b 

At line no: 25 	simple_expression: term

b 

At line no: 25 	rel_expression: simple_expression

b 

At line no: 25 	logic_expression: rel_expression

b 

At line no: 25 	arguments: arguments COMMA logic_expression

b 

At line no: 25 	argument_list: arguments

b 

At line no: 25 	factor: ID LPAREN argument_list RPAREN

bar ( b ) 

At line no: 25 	unary_expression: factor

bar ( b ) 

At line no: 25 	term: unary_expression

bar ( b ) 

At line no: 25 	simple_expression: simple_expression ADDOP term

a - bar ( b ) 

At line no: 25 	variable: ID

c 

At line no: 25 	factor: variable

c 

At line no: 25 	unary_expression: factor

c 

At line no: 25 	term: unary_expression

c 

At line no: 25 	simple_expression: simple_expression ADDOP term

a - bar ( b ) + c 

At line no: 25 	rel_expression: simple_expression

a - bar ( b ) + c 

At line no: 25 	logic_expression: rel_expression

a - bar ( b ) + c 

At line no: 25 	expression: logic_expression

a - bar ( b ) + c 

At line no: 25 	statement: RETURN expression SEMICOLON

return a - bar ( b ) + c ; 


At line no: 25 	statements: statement

return a - bar ( b ) + c ; 


 ScopeTable # 1
 0 --> < b : ID >
 1 --> < c : ID >
 6 --> < a : ID >

At line no: 26 	compound_statement: LCURL statements RCURL

{ 
  return a - bar ( b ) + c ; 
} 


At line no: 26 	func_definition: type_specifier ID LPAREN parameter_list RPAREN compound_statement

int func ( int a , int b , int c ) { 
  return a - bar ( b ) + c ; 
} 


At line no: 26 	unit: func_definition

int func ( int a , int b , int c ) { 
  return a - bar ( b ) + c ; 
} 


At line no: 26 	program: program unit

int bar ( float x ) { 
  if ( x < 0 ) return - x ; 
  return x ; 
} 
void foo ( ) { 
  return bar ; 
} 
int oops ( ) { 
  return 0 ; 
} 
int oops ( int pos ) { 
  int pos ; 
  pos = 5 ; 
  oops = pos * 9 + 2.5 ; 
} 
int func ( int , float , int ) ; 
int func ( int a , int b , int c ) { 
  return a - bar ( b ) + c ; 
} 


At line no: 28 	type_specifier: INT

int 

At line no: 28 	type_specifier: INT

int 

At line no: 28 	parameter_list: type_specifier ID

int a 

At line no: 28 	type_specifier: FLOAT

float 

At line no: 28 	parameter_list: parameter_list COMMA type_specifier ID

int a , float b 

At line no: 28 	type_specifier: INT

int 

At line no: 28 	parameter_list: parameter_list COMMA type_specifier ID

int a , float b , int c 

At line no: 29 	variable: ID

a 

At line no: 29 	factor: variable

a 

At line no: 29 	unary_expression: factor

a 

At line no: 29 	term: unary_expression

a 

At line no: 29 	simple_expression: term

a 

At line no: 29 	variable: ID

b 

At line no: 29 	factor: variable

b 

At line no: 29 	unary_expression: factor

b 

At line no: 29 	term: unary_expression

b 

At line no: 29 	simple_expression: term

b 

At line no: 29 	rel_expression: simple_expression

b 

At line no: 29 	logic_expression: rel_expression

b 

At line no: 29 	arguments: arguments COMMA logic_expression

b 

At line no: 29 	argument_list: arguments

b 

At line no: 29 	factor: ID LPAREN argument_list RPAREN

bar ( b ) 

At line no: 29 	unary_expression: factor

bar ( b ) 

At line no: 29 	term: unary_expression

bar ( b ) 

At line no: 29 	simple_expression: simple_expression ADDOP term

a - bar ( b ) 

At line no: 29 	variable: ID

c 

At line no: 29 	factor: variable

c 

At line no: 29 	unary_expression: factor

c 

At line no: 29 	term: unary_expression

c 

At line no: 29 	simple_expression: simple_expression ADDOP term

a - bar ( b ) + c 

At line no: 29 	rel_expression: simple_expression

a - bar ( b ) + c 

At line no: 29 	logic_expression: rel_expression

a - bar ( b ) + c 

At line no: 29 	expression: logic_expression

a - bar ( b ) + c 

At line no: 29 	statement: RETURN expression SEMICOLON

return a - bar ( b ) + c ; 


At line no: 29 	statements: statement

return a - bar ( b ) + c ; 


 ScopeTable # 1
 0 --> < b : ID >
 1 --> < c : ID >
 6 --> < a : ID >

At line no: 30 	compound_statement: LCURL statements RCURL

{ 
  return a - bar ( b ) + c ; 
} 


At line no: 30 	func_definition: type_specifier ID LPAREN parameter_list RPAREN compound_statement

int func ( int a , float b , int c ) { 
  return a - bar ( b ) + c ; 
} 


At line no: 30 	unit: func_definition

int func ( int a , float b , int c ) { 
  return a - bar ( b ) + c ; 
} 


At line no: 30 	program: program unit

int bar ( float x ) { 
  if ( x < 0 ) return - x ; 
  return x ; 
} 
void foo ( ) { 
  return bar ; 
} 
int oops ( ) { 
  return 0 ; 
} 
int oops ( int pos ) { 
  int pos ; 
  pos = 5 ; 
  oops = pos * 9 + 2.5 ; 
} 
int func ( int , float , int ) ; 
int func ( int a , int b , int c ) { 
  return a - bar ( b ) + c ; 
} 
int func ( int a , float b , int c ) { 
  return a - bar ( b ) + c ; 
} 


At line no: 32 	type_specifier: INT

int 

At line no: 32 	type_specifier: INT

int 

At line no: 32 	parameter_list: type_specifier ID

int p 

At line no: 32 	type_specifier: FLOAT

float 

At line no: 32 	parameter_list: parameter_list COMMA type_specifier ID

int p , float r 

At line no: 32 	type_specifier: INT

int 

At line no: 32 	parameter_list: parameter_list COMMA type_specifier ID

int p , float r , int q 

At line no: 33 	variable: ID

p 

At line no: 33 	factor: variable

p 

At line no: 33 	unary_expression: factor

p 

At line no: 33 	term: unary_expression

p 

At line no: 33 	simple_expression: term

p 

At line no: 33 	variable: ID

q 

At line no: 33 	factor: variable

q 

At line no: 33 	unary_expression: factor

q 

At line no: 33 	term: unary_expression

q 

At line no: 33 	simple_expression: simple_expression ADDOP term

p - q 

At line no: 33 	rel_expression: simple_expression

p - q 

At line no: 33 	logic_expression: rel_expression

p - q 

At line no: 33 	expression: logic_expression

p - q 

At line no: 33 	statement: RETURN expression SEMICOLON

return p - q ; 


At line no: 33 	statements: statement

return p - q ; 


 ScopeTable # 1
 0 --> < p : ID >
 1 --> < q : ID >
 2 --> < r : ID >

At line no: 34 	compound_statement: LCURL statements RCURL

{ 
  return p - q ; 
} 


At line no: 34 	func_definition: type_specifier ID LPAREN parameter_list RPAREN compound_statement

int func ( int p , float r , int q ) { 
  return p - q ; 
} 


At line no: 34 	unit: func_definition

int func ( int p , float r , int q ) { 
  return p - q ; 
} 


At line no: 34 	program: program unit

int bar ( float x ) { 
  if ( x < 0 ) return - x ; 
  return x ; 
} 
void foo ( ) { 
  return bar ; 
} 
int oops ( ) { 
  return 0 ; 
} 
int oops ( int pos ) { 
  int pos ; 
  pos = 5 ; 
  oops = pos * 9 + 2.5 ; 
} 
int func ( int , float , int ) ; 
int func ( int a , int b , int c ) { 
  return a - bar ( b ) + c ; 
} 
int func ( int a , float b , int c ) { 
  return a - bar ( b ) + c ; 
} 
int func ( int p , float r , int q ) { 
  return p - q ; 
} 


At line no: 36 	type_specifier: INT

int 

At line no: 36 	declaration_list: ID LTHIRD CONST_INT RTHIRD

arr [ 100 ] 

At line no: 36 	var_declaration: type_specifier declaration_list SEMICOLON

int arr [ 100 ] ; 


At line no: 36 	unit: var_declaration

int arr [ 100 ] ; 


At line no: 36 	program: program unit

int bar ( float x ) { 
  if ( x < 0 ) return - x ; 
  return x ; 
} 
void foo ( ) { 
  return bar ; 
} 
int oops ( ) { 
  return 0 ; 
} 
int oops ( int pos ) { 
  int pos ; 
  pos = 5 ; 
  oops = pos * 9 + 2.5 ; 
} 
int func ( int , float , int ) ; 
int func ( int a , int b , int c ) { 
  return a - bar ( b ) + c ; 
} 
int func ( int a , float b , int c ) { 
  return a - bar ( b ) + c ; 
} 
int func ( int p , float r , int q ) { 
  return p - q ; 
} 
int arr [ 100 ] ; 


At line no: 38 	type_specifier: INT

int 

At line no: 38 	type_specifier: VOID

void 

At line no: 38 	parameter_list: type_specifier

void 

At line no: 39 	type_specifier: INT

int 

At line no: 39 	declaration_list: ID

x 

At line no: 39 	declaration_list: declaration_list COMMA ID

x , y 

At line no: 39 	var_declaration: type_specifier declaration_list SEMICOLON

int x , y ; 


At line no: 39 	statement: var_declaration

int x , y ; 


At line no: 39 	statements: statement

int x , y ; 


At line no: 40 	type_specifier: FLOAT

float 

At line no: 40 	declaration_list: ID

z 

At line no: 40 	var_declaration: type_specifier declaration_list SEMICOLON

float z ; 


At line no: 40 	statement: var_declaration

float z ; 


At line no: 40 	statements: statements statement

int x , y ; 
float z ; 


At line no: 42 	variable: ID

x 

At line no: 42 	factor: CONST_INT

2 

At line no: 42 	unary_expression: factor

2 

At line no: 42 	term: unary_expression

2 

At line no: 42 	simple_expression: term

2 

At line no: 42 	rel_expression: simple_expression

2 

At line no: 42 	logic_expression: rel_expression

2 

At line no: 42 	expression: variable ASSIGNOP logic_expression

x = 2 

At line no: 42 	expression_statement: expression SEMICOLON

x = 2 ; 


At line no: 42 	statement: expression_statement

x = 2 ; 


At line no: 42 	statements: statements statement

int x , y ; 
float z ; 
x = 2 ; 


At line no: 43 	variable: ID

y 

At line no: 43 	variable: ID

x 

At line no: 43 	factor: variable

x 

At line no: 43 	unary_expression: factor

x 

At line no: 43 	term: unary_expression

x 

At line no: 43 	factor: CONST_INT

45 

At line no: 43 	unary_expression: factor

45 

At line no: 43 	term: term MULOP unary_expression

x * 45 

At line no: 43 	simple_expression: term

x * 45 

At line no: 43 	rel_expression: simple_expression

x * 45 

At line no: 43 	logic_expression: rel_expression

x * 45 

At line no: 43 	expression: variable ASSIGNOP logic_expression

y = x * 45 

At line no: 43 	expression_statement: expression SEMICOLON

y = x * 45 ; 


At line no: 43 	statement: expression_statement

y = x * 45 ; 


At line no: 43 	statements: statements statement

int x , y ; 
float z ; 
x = 2 ; 
y = x * 45 ; 


At line no: 44 	variable: ID

z 

At line no: 44 	variable: ID

x 

At line no: 44 	factor: variable

x 

At line no: 44 	unary_expression: factor

x 

At line no: 44 	term: unary_expression

x 

At line no: 44 	variable: ID

y 

At line no: 44 	factor: variable

y 

At line no: 44 	unary_expression: factor

y 

At line no: 44 	term: term MULOP unary_expression

x * y 

At line no: 44 	factor: CONST_FLOAT

1.0 

At line no: 44 	unary_expression: factor

1.0 

At line no: 44 	term: term MULOP unary_expression

x * y / 1.0 

At line no: 44 	factor: CONST_FLOAT

0.5 

At line no: 44 	unary_expression: factor

0.5 

At line no: 44 	term: term MULOP unary_expression

x * y / 1.0 * 0.5 

At line no: 44 	simple_expression: term

x * y / 1.0 * 0.5 

At line no: 44 	rel_expression: simple_expression

x * y / 1.0 * 0.5 

At line no: 44 	logic_expression: rel_expression

x * y / 1.0 * 0.5 

At line no: 44 	expression: variable ASSIGNOP logic_expression

z = x * y / 1.0 * 0.5 

At line no: 44 	expression_statement: expression SEMICOLON

z = x * y / 1.0 * 0.5 ; 


At line no: 44 	statement: expression_statement

z = x * y / 1.0 * 0.5 ; 


At line no: 44 	statements: statements statement

int x , y ; 
float z ; 
x = 2 ; 
y = x * 45 ; 
z = x * y / 1.0 * 0.5 ; 


At line no: 46 	variable: ID

z 

At line no: 46 	factor: variable

z 

At line no: 46 	unary_expression: factor

z 

At line no: 46 	term: unary_expression

z 

At line no: 46 	simple_expression: term

z 

At line no: 46 	rel_expression: simple_expression

z 

At line no: 46 	logic_expression: rel_expression

z 

At line no: 46 	expression: logic_expression

z 

At line no: 46 	variable: ID LTHIRD expression RTHIRD

arr [ z ] 

At line no: 46 	variable: ID

x 

At line no: 46 	factor: variable

x 

At line no: 46 	unary_expression: factor

x 

At line no: 46 	term: unary_expression

x 

At line no: 46 	simple_expression: term

x 

At line no: 46 	rel_expression: simple_expression

x 

At line no: 46 	logic_expression: rel_expression

x 

At line no: 46 	expression: variable ASSIGNOP logic_expression

arr [ z ] = x 

At line no: 46 	expression_statement: expression SEMICOLON

arr [ z ] = x ; 


At line no: 46 	statement: expression_statement

arr [ z ] = x ; 


At line no: 46 	statements: statements statement

int x , y ; 
float z ; 
x = 2 ; 
y = x * 45 ; 
z = x * y / 1.0 * 0.5 ; 
arr [ z ] = x ; 


At line no: 47 	variable: ID

x 

At line no: 47 	factor: variable

x 

At line no: 47 	unary_expression: factor

x 

At line no: 47 	term: unary_expression

x 

At line no: 47 	simple_expression: term

x 

At line no: 47 	variable: ID

z 

At line no: 47 	factor: variable

z 

At line no: 47 	unary_expression: factor

z 

At line no: 47 	term: unary_expression

z 

At line no: 47 	simple_expression: term

z 

At line no: 47 	rel_expression: simple_expression

x > z 

At line no: 47 	logic_expression: rel_expression

x > z 

At line no: 47 	expression: logic_expression

x > z 

At line no: 47 	variable: ID LTHIRD expression RTHIRD

arr [ x > z ] 

At line no: 47 	variable: ID

y 

At line no: 47 	factor: variable

y 

At line no: 47 	unary_expression: factor

y 

At line no: 47 	term: unary_expression

y 

At line no: 47 	simple_expression: term

y 

At line no: 47 	rel_expression: simple_expression

y 

At line no: 47 	logic_expression: rel_expression

y 

At line no: 47 	expression: variable ASSIGNOP logic_expression

arr [ x > z ] = y 

At line no: 47 	expression_statement: expression SEMICOLON

arr [ x > z ] = y ; 


At line no: 47 	statement: expression_statement

arr [ x > z ] = y ; 


At line no: 47 	statements: statements statement

int x , y ; 
float z ; 
x = 2 ; 
y = x * 45 ; 
z = x * y / 1.0 * 0.5 ; 
arr [ z ] = x ; 
arr [ x > z ] = y ; 


At line no: 48 	variable: ID

y 

At line no: 48 	factor: variable

y 

At line no: 48 	unary_expression: factor

y 

At line no: 48 	term: unary_expression

y 

At line no: 48 	simple_expression: term

y 

At line no: 48 	variable: ID

z 

At line no: 48 	factor: variable

z 

At line no: 48 	unary_expression: factor

z 

At line no: 48 	term: unary_expression

z 

At line no: 48 	factor: CONST_FLOAT

2.0 

At line no: 48 	unary_expression: factor

2.0 

At line no: 48 	term: term MULOP unary_expression

z * 2.0 

At line no: 48 	simple_expression: term

z * 2.0 

At line no: 48 	rel_expression: simple_expression

y > z * 2.0 

At line no: 48 	logic_expression: rel_expression

y > z * 2.0 

At line no: 48 	expression: logic_expression

y > z * 2.0 

At line no: 48 	variable: ID LTHIRD expression RTHIRD

arr [ y > z * 2.0 ] 

At line no: 48 	variable: ID

z 

At line no: 48 	factor: variable

z 

At line no: 48 	unary_expression: factor

z 

At line no: 48 	term: unary_expression

z 

At line no: 48 	simple_expression: term

z 

At line no: 48 	rel_expression: simple_expression

z 

At line no: 48 	logic_expression: rel_expression

z 

At line no: 48 	expression: variable ASSIGNOP logic_expression

arr [ y > z * 2.0 ] = z 

At line no: 48 	expression_statement: expression SEMICOLON

arr [ y > z * 2.0 ] = z ; 


At line no: 48 	statement: expression_statement

arr [ y > z * 2.0 ] = z ; 


At line no: 48 	statements: statements statement

int x , y ; 
float z ; 
x = 2 ; 
y = x * 45 ; 
z = x * y / 1.0 * 0.5 ; 
arr [ z ] = x ; 
arr [ x > z ] = y ; 
arr [ y > z * 2.0 ] = z ; 


At line no: 50 	type_specifier: FLOAT

float 

At line no: 50 	declaration_list: ID

some_val 

At line no: 50 	var_declaration: type_specifier declaration_list SEMICOLON

float some_val ; 


At line no: 50 	statement: var_declaration

float some_val ; 


At line no: 50 	statements: statements statement

int x , y ; 
float z ; 
x = 2 ; 
y = x * 45 ; 
z = x * y / 1.0 * 0.5 ; 
arr [ z ] = x ; 
arr [ x > z ] = y ; 
arr [ y > z * 2.0 ] = z ; 
float some_val ; 


At line no: 51 	variable: ID

some_val 

At line no: 51 	variable: ID

x 

At line no: 51 	factor: variable

x 

At line no: 51 	unary_expression: factor

x 

At line no: 51 	term: unary_expression

x 

At line no: 51 	simple_expression: term

x 

At line no: 51 	rel_expression: simple_expression

x 

At line no: 51 	logic_expression: rel_expression

x 

At line no: 51 	arguments: arguments COMMA logic_expression

x 

At line no: 51 	variable: ID

z 

At line no: 51 	factor: variable

z 

At line no: 51 	unary_expression: factor

z 

At line no: 51 	term: unary_expression

z 

At line no: 51 	simple_expression: term

z 

At line no: 51 	rel_expression: simple_expression

z 

At line no: 51 	logic_expression: rel_expression

z 

At line no: 51 	arguments: arguments COMMA logic_expression

x , z 

At line no: 51 	variable: ID

y 

At line no: 51 	factor: variable

y 

At line no: 51 	unary_expression: factor

y 

At line no: 51 	term: unary_expression

y 

At line no: 51 	simple_expression: term

y 

At line no: 51 	rel_expression: simple_expression

y 

At line no: 51 	logic_expression: rel_expression

y 

At line no: 51 	arguments: arguments COMMA logic_expression

x , z , y 

At line no: 51 	argument_list: arguments

x , z , y 

At line no: 51 	factor: ID LPAREN argument_list RPAREN

func ( x , z , y ) 

At line no: 51 	unary_expression: factor

func ( x , z , y ) 

At line no: 51 	term: unary_expression

func ( x , z , y ) 

At line no: 51 	simple_expression: term

func ( x , z , y ) 

At line no: 51 	rel_expression: simple_expression

func ( x , z , y ) 

At line no: 51 	logic_expression: rel_expression

func ( x , z , y ) 

At line no: 51 	expression: variable ASSIGNOP logic_expression

some_val = func ( x , z , y ) 

At line no: 51 	expression_statement: expression SEMICOLON

some_val = func ( x , z , y ) ; 


At line no: 51 	statement: expression_statement

some_val = func ( x , z , y ) ; 


At line no: 51 	statements: statements statement

int x , y ; 
float z ; 
x = 2 ; 
y = x * 45 ; 
z = x * y / 1.0 * 0.5 ; 
arr [ z ] = x ; 
arr [ x > z ] = y ; 
arr [ y > z * 2.0 ] = z ; 
float some_val ; 
some_val = func ( x , z , y ) ; 


At line no: 53 	variable: ID

foo 

At line no: 53 	argument_list: 



At line no: 53 	factor: ID LPAREN argument_list RPAREN

foo ( ) 

At line no: 53 	unary_expression: factor

foo ( ) 

At line no: 53 	term: unary_expression

foo ( ) 

At line no: 53 	factor: CONST_INT

2 

At line no: 53 	unary_expression: factor

2 

At line no: 53 	term: term MULOP unary_expression

foo ( ) % 2 

At line no: 53 	simple_expression: term

foo ( ) % 2 

At line no: 53 	rel_expression: simple_expression

foo ( ) % 2 

At line no: 53 	logic_expression: rel_expression

foo ( ) % 2 

At line no: 53 	expression: variable ASSIGNOP logic_expression

foo = foo ( ) % 2 

At line no: 53 	expression_statement: expression SEMICOLON

foo = foo ( ) % 2 ; 


At line no: 53 	statement: expression_statement

foo = foo ( ) % 2 ; 


At line no: 53 	statements: statements statement

int x , y ; 
float z ; 
x = 2 ; 
y = x * 45 ; 
z = x * y / 1.0 * 0.5 ; 
arr [ z ] = x ; 
arr [ x > z ] = y ; 
arr [ y > z * 2.0 ] = z ; 
float some_val ; 
some_val = func ( x , z , y ) ; 
foo = foo ( ) % 2 ; 


At line no: 54 	argument_list: 



At line no: 54 	factor: ID LPAREN argument_list RPAREN

foo ( ) 

At line no: 54 	unary_expression: factor

foo ( ) 

At line no: 54 	term: unary_expression

foo ( ) 

At line no: 54 	simple_expression: term

foo ( ) 

At line no: 54 	rel_expression: simple_expression

foo ( ) 

At line no: 54 	logic_expression: rel_expression

foo ( ) 

At line no: 54 	expression: logic_expression

foo ( ) 

At line no: 54 	expression_statement: expression SEMICOLON

foo ( ) ; 


At line no: 54 	statement: expression_statement

foo ( ) ; 


At line no: 54 	statements: statements statement

int x , y ; 
float z ; 
x = 2 ; 
y = x * 45 ; 
z = x * y / 1.0 * 0.5 ; 
arr [ z ] = x ; 
arr [ x > z ] = y ; 
arr [ y > z * 2.0 ] = z ; 
float some_val ; 
some_val = func ( x , z , y ) ; 
foo = foo ( ) % 2 ; 
foo ( ) ; 


At line no: 56 	type_specifier: INT

int 

At line no: 56 	declaration_list: ID

i 

At line no: 56 	declaration_list: declaration_list COMMA ID

i , odd 

At line no: 56 	declaration_list: declaration_list COMMA ID

i , odd , even 

At line no: 56 	var_declaration: type_specifier declaration_list SEMICOLON

int i , odd , even ; 


At line no: 56 	statement: var_declaration

int i , odd , even ; 


At line no: 56 	statements: statements statement

int x , y ; 
float z ; 
x = 2 ; 
y = x * 45 ; 
z = x * y / 1.0 * 0.5 ; 
arr [ z ] = x ; 
arr [ x > z ] = y ; 
arr [ y > z * 2.0 ] = z ; 
float some_val ; 
some_val = func ( x , z , y ) ; 
foo = foo ( ) % 2 ; 
foo ( ) ; 
int i , odd , even ; 


At line no: 57 	variable: ID

odd 

At line no: 57 	factor: CONST_INT

0 

At line no: 57 	unary_expression: factor

0 

At line no: 57 	term: unary_expression

0 

At line no: 57 	simple_expression: term

0 

At line no: 57 	rel_expression: simple_expression

0 

At line no: 57 	logic_expression: rel_expression

0 

At line no: 57 	expression: variable ASSIGNOP logic_expression

odd = 0 

At line no: 57 	expression_statement: expression SEMICOLON

odd = 0 ; 


At line no: 57 	statement: expression_statement

odd = 0 ; 


At line no: 57 	statements: statements statement

int x , y ; 
float z ; 
x = 2 ; 
y = x * 45 ; 
z = x * y / 1.0 * 0.5 ; 
arr [ z ] = x ; 
arr [ x > z ] = y ; 
arr [ y > z * 2.0 ] = z ; 
float some_val ; 
some_val = func ( x , z , y ) ; 
foo = foo ( ) % 2 ; 
foo ( ) ; 
int i , odd , even ; 
odd = 0 ; 


At line no: 58 	variable: ID

even 

At line no: 58 	factor: CONST_INT

0 

At line no: 58 	unary_expression: factor

0 

At line no: 58 	term: unary_expression

0 

At line no: 58 	simple_expression: term

0 

At line no: 58 	rel_expression: simple_expression

0 

At line no: 58 	logic_expression: rel_expression

0 

At line no: 58 	expression: variable ASSIGNOP logic_expression

even = 0 

At line no: 58 	expression_statement: expression SEMICOLON

even = 0 ; 


At line no: 58 	statement: expression_statement

even = 0 ; 


At line no: 58 	statements: statements statement

int x , y ; 
float z ; 
x = 2 ; 
y = x * 45 ; 
z = x * y / 1.0 * 0.5 ; 
arr [ z ] = x ; 
arr [ x > z ] = y ; 
arr [ y > z * 2.0 ] = z ; 
float some_val ; 
some_val = func ( x , z , y ) ; 
foo = foo ( ) % 2 ; 
foo ( ) ; 
int i , odd , even ; 
odd = 0 ; 
even = 0 ; 


At line no: 59 	variable: ID

i 

At line no: 59 	factor: CONST_INT

0 

At line no: 59 	unary_expression: factor

0 

At line no: 59 	term: unary_expression

0 

At line no: 59 	simple_expression: term

0 

At line no: 59 	rel_expression: simple_expression

0 

At line no: 59 	logic_expression: rel_expression

0 

At line no: 59 	expression: variable ASSIGNOP logic_expression

i = 0 

At line no: 59 	expression_statement: expression SEMICOLON

i = 0 ; 


At line no: 59 	variable: ID

i 

At line no: 59 	factor: variable

i 

At line no: 59 	unary_expression: factor

i 

At line no: 59 	term: unary_expression

i 

At line no: 59 	simple_expression: term

i 

At line no: 59 	factor: CONST_INT

10 

At line no: 59 	unary_expression: factor

10 

At line no: 59 	term: unary_expression

10 

At line no: 59 	simple_expression: term

10 

At line no: 59 	rel_expression: simple_expression

i < 10 

At line no: 59 	logic_expression: rel_expression

i < 10 

At line no: 59 	expression: logic_expression

i < 10 

At line no: 59 	expression_statement: expression SEMICOLON

i < 10 ; 


At line no: 59 	variable: ID

i 

At line no: 59 	factor: variable INCOP

i ++ 

At line no: 59 	unary_expression: factor

i ++ 

At line no: 59 	term: unary_expression

i ++ 

At line no: 59 	simple_expression: term

i ++ 

At line no: 59 	rel_expression: simple_expression

i ++ 

At line no: 59 	logic_expression: rel_expression

i ++ 

At line no: 59 	expression: logic_expression

i ++ 

At line no: 60 	variable: ID

i 

At line no: 60 	factor: variable

i 

At line no: 60 	unary_expression: factor

i 

At line no: 60 	term: unary_expression

i 

At line no: 60 	factor: CONST_INT

2 

At line no: 60 	unary_expression: factor

2 

At line no: 60 	term: term MULOP unary_expression

i % 2 

At line no: 60 	simple_expression: term

i % 2 

At line no: 60 	factor: CONST_INT

0 

At line no: 60 	unary_expression: factor

0 

At line no: 60 	term: unary_expression

0 

At line no: 60 	simple_expression: term

0 

At line no: 60 	rel_expression: simple_expression

i % 2 == 0 

At line no: 60 	logic_expression: rel_expression

i % 2 == 0 

At line no: 60 	expression: logic_expression

i % 2 == 0 

At line no: 60 	variable: ID

even 

At line no: 60 	factor: variable INCOP

even ++ 

At line no: 60 	unary_expression: factor

even ++ 

At line no: 60 	term: unary_expression

even ++ 

At line no: 60 	simple_expression: term

even ++ 

At line no: 60 	rel_expression: simple_expression

even ++ 

At line no: 60 	logic_expression: rel_expression

even ++ 

At line no: 60 	expression: logic_expression

even ++ 

At line no: 60 	expression_statement: expression SEMICOLON

even ++ ; 


At line no: 60 	statement: expression_statement

even ++ ; 


At line no: 61 	variable: ID

odd 

At line no: 61 	factor: variable INCOP

odd ++ 

At line no: 61 	unary_expression: factor

odd ++ 

At line no: 61 	term: unary_expression

odd ++ 

At line no: 61 	simple_expression: term

odd ++ 

At line no: 61 	rel_expression: simple_expression

odd ++ 

At line no: 61 	logic_expression: rel_expression

odd ++ 

At line no: 61 	expression: logic_expression

odd ++ 

At line no: 61 	expression_statement: expression SEMICOLON

odd ++ ; 


At line no: 61 	statement: expression_statement

odd ++ ; 


At line no: 61 	statement: IF LPAREN expression RPAREN statement ELSE statement

if ( i % 2 == 0 ) even ++ ; 
else odd ++ ; 


At line no: 61 	statements: statement

if ( i % 2 == 0 ) even ++ ; 
else odd ++ ; 


 ScopeTable # 2

At line no: 62 	compound_statement: LCURL statements RCURL

{ 
  if ( i % 2 == 0 ) even ++ ; 
  else odd ++ ; 
} 


At line no: 62 	statement: compound_statement

{ 
  if ( i % 2 == 0 ) even ++ ; 
  else odd ++ ; 
} 


At line no: 62 	statement: FOR LPAREN expression_statement expression_statement expression RPAREN statement

for ( i = 0 ; 
i < 10 ; 
i ++ ) { 
  if ( i % 2 == 0 ) even ++ ; 
  else odd ++ ; 
} 


At line no: 62 	statements: statements statement

int x , y ; 
float z ; 
x = 2 ; 
y = x * 45 ; 
z = x * y / 1.0 * 0.5 ; 
arr [ z ] = x ; 
arr [ x > z ] = y ; 
arr [ y > z * 2.0 ] = z ; 
float some_val ; 
some_val = func ( x , z , y ) ; 
foo = foo ( ) % 2 ; 
foo ( ) ; 
int i , odd , even ; 
odd = 0 ; 
even = 0 ; 
for ( i = 0 ; 
i < 10 ; 
i ++ ) { 
  if ( i % 2 == 0 ) even ++ ; 
  else odd ++ ; 
} 


At line no: 64 	variable: ID

i 

At line no: 64 	factor: variable

i 

At line no: 64 	unary_expression: factor

i 

At line no: 64 	term: unary_expression

i 

At line no: 64 	simple_expression: term

i 

At line no: 64 	factor: CONST_INT

0 

At line no: 64 	unary_expression: factor

0 

At line no: 64 	term: unary_expression

0 

At line no: 64 	simple_expression: term

0 

At line no: 64 	rel_expression: simple_expression

i > 0 

At line no: 64 	logic_expression: rel_expression

i > 0 

At line no: 64 	expression: logic_expression

i > 0 

At line no: 65 	variable: ID

odd 

At line no: 65 	factor: variable

odd 

At line no: 65 	unary_expression: factor

odd 

At line no: 65 	term: unary_expression

odd 

At line no: 65 	simple_expression: term

odd 

At line no: 65 	variable: ID

even 

At line no: 65 	factor: variable

even 

At line no: 65 	unary_expression: factor

even 

At line no: 65 	term: unary_expression

even 

At line no: 65 	simple_expression: term

even 

At line no: 65 	rel_expression: simple_expression

odd > even 

At line no: 65 	logic_expression: rel_expression

odd > even 

At line no: 65 	expression: logic_expression

odd > even 

At line no: 66 	variable: ID

even 

At line no: 66 	factor: variable

even 

At line no: 66 	unary_expression: factor

even 

At line no: 66 	term: unary_expression

even 

At line no: 66 	simple_expression: term

even 

At line no: 66 	variable: ID

i 

At line no: 66 	factor: variable

i 

At line no: 66 	unary_expression: factor

i 

At line no: 66 	term: unary_expression

i 

At line no: 66 	simple_expression: term

i 

At line no: 66 	rel_expression: simple_expression

even == i 

At line no: 66 	logic_expression: rel_expression

even == i 

At line no: 66 	expression: logic_expression

even == i 

At line no: 66 	variable: ID

cnt 

At line no: 66 	factor: variable INCOP

cnt -- 

At line no: 66 	unary_expression: factor

cnt -- 

At line no: 66 	term: unary_expression

cnt -- 

At line no: 66 	simple_expression: term

cnt -- 

At line no: 66 	rel_expression: simple_expression

cnt -- 

At line no: 66 	logic_expression: rel_expression

cnt -- 

At line no: 66 	expression: logic_expression

cnt -- 

At line no: 66 	expression_statement: expression SEMICOLON

cnt -- ; 


At line no: 66 	statement: expression_statement

cnt -- ; 


At line no: 67 	variable: ID

cnt 

At line no: 67 	factor: variable INCOP

cnt ++ 

At line no: 67 	unary_expression: factor

cnt ++ 

At line no: 67 	term: unary_expression

cnt ++ 

At line no: 67 	simple_expression: term

cnt ++ 

At line no: 67 	rel_expression: simple_expression

cnt ++ 

At line no: 67 	logic_expression: rel_expression

cnt ++ 

At line no: 67 	expression: logic_expression

cnt ++ 

At line no: 67 	expression_statement: expression SEMICOLON

cnt ++ ; 


At line no: 67 	statement: expression_statement

cnt ++ ; 


At line no: 67 	statement: IF LPAREN expression RPAREN statement ELSE statement

if ( even == i ) cnt -- ; 
else cnt ++ ; 


At line no: 69 	variable: ID

odd 

At line no: 69 	factor: variable

odd 

At line no: 69 	unary_expression: factor

odd 

At line no: 69 	term: unary_expression

odd 

At line no: 69 	simple_expression: term

odd 

At line no: 69 	variable: ID

i 

At line no: 69 	factor: variable

i 

At line no: 69 	unary_expression: factor

i 

At line no: 69 	term: unary_expression

i 

At line no: 69 	simple_expression: term

i 

At line no: 69 	rel_expression: simple_expression

odd == i 

At line no: 69 	logic_expression: rel_expression

odd == i 

At line no: 69 	expression: logic_expression

odd == i 

At line no: 69 	variable: ID

cnt 

At line no: 69 	factor: variable INCOP

cnt ++ 

At line no: 69 	unary_expression: factor

cnt ++ 

At line no: 69 	term: unary_expression

cnt ++ 

At line no: 69 	simple_expression: term

cnt ++ 

At line no: 69 	rel_expression: simple_expression

cnt ++ 

At line no: 69 	logic_expression: rel_expression

cnt ++ 

At line no: 69 	expression: logic_expression

cnt ++ 

At line no: 69 	expression_statement: expression SEMICOLON

cnt ++ ; 


At line no: 69 	statement: expression_statement

cnt ++ ; 


At line no: 70 	variable: ID

cnt 

At line no: 70 	factor: variable INCOP

cnt -- 

At line no: 70 	unary_expression: factor

cnt -- 

At line no: 70 	term: unary_expression

cnt -- 

At line no: 70 	simple_expression: term

cnt -- 

At line no: 70 	rel_expression: simple_expression

cnt -- 

At line no: 70 	logic_expression: rel_expression

cnt -- 

At line no: 70 	expression: logic_expression

cnt -- 

At line no: 70 	expression_statement: expression SEMICOLON

cnt -- ; 


At line no: 70 	statement: expression_statement

cnt -- ; 


At line no: 70 	statement: IF LPAREN expression RPAREN statement ELSE statement

if ( odd == i ) cnt ++ ; 
else cnt -- ; 


At line no: 70 	statement: IF LPAREN expression RPAREN statement ELSE statement

if ( odd > even ) if ( even == i ) cnt -- ; 
else cnt ++ ; 
else if ( odd == i ) cnt ++ ; 
else cnt -- ; 


At line no: 70 	statements: statement

if ( odd > even ) if ( even == i ) cnt -- ; 
else cnt ++ ; 
else if ( odd == i ) cnt ++ ; 
else cnt -- ; 


At line no: 71 	variable: ID

i 

At line no: 71 	factor: variable INCOP

i -- 

At line no: 71 	unary_expression: factor

i -- 

At line no: 71 	term: unary_expression

i -- 

At line no: 71 	simple_expression: term

i -- 

At line no: 71 	rel_expression: simple_expression

i -- 

At line no: 71 	logic_expression: rel_expression

i -- 

At line no: 71 	expression: logic_expression

i -- 

At line no: 71 	expression_statement: expression SEMICOLON

i -- ; 


At line no: 71 	statement: expression_statement

i -- ; 


At line no: 71 	statements: statements statement

if ( odd > even ) if ( even == i ) cnt -- ; 
else cnt ++ ; 
else if ( odd == i ) cnt ++ ; 
else cnt -- ; 
i -- ; 


 ScopeTable # 2

At line no: 72 	compound_statement: LCURL statements RCURL

{ 
  if ( odd > even ) if ( even == i ) cnt -- ; 
  else cnt ++ ; 
  else if ( odd == i ) cnt ++ ; 
  else cnt -- ; 
  i -- ; 
} 


At line no: 72 	statement: compound_statement

{ 
  if ( odd > even ) if ( even == i ) cnt -- ; 
  else cnt ++ ; 
  else if ( odd == i ) cnt ++ ; 
  else cnt -- ; 
  i -- ; 
} 


At line no: 72 	statement: WHILE LPAREN expression RPAREN statement

while ( i > 0 ) { 
  if ( odd > even ) if ( even == i ) cnt -- ; 
  else cnt ++ ; 
  else if ( odd == i ) cnt ++ ; 
  else cnt -- ; 
  i -- ; 
} 


At line no: 72 	statements: statements statement

int x , y ; 
float z ; 
x = 2 ; 
y = x * 45 ; 
z = x * y / 1.0 * 0.5 ; 
arr [ z ] = x ; 
arr [ x > z ] = y ; 
arr [ y > z * 2.0 ] = z ; 
float some_val ; 
some_val = func ( x , z , y ) ; 
foo = foo ( ) % 2 ; 
foo ( ) ; 
int i , odd , even ; 
odd = 0 ; 
even = 0 ; 
for ( i = 0 ; 
i < 10 ; 
i ++ ) { 
  if ( i % 2 == 0 ) even ++ ; 
  else odd ++ ; 
} 
while ( i > 0 ) { 
  if ( odd > even ) if ( even == i ) cnt -- ; 
  else cnt ++ ; 
  else if ( odd == i ) cnt ++ ; 
  else cnt -- ; 
  i -- ; 
} 


At line no: 74 	factor: CONST_INT

0 

At line no: 74 	unary_expression: factor

0 

At line no: 74 	term: unary_expression

0 

At line no: 74 	simple_expression: term

0 

At line no: 74 	rel_expression: simple_expression

0 

At line no: 74 	logic_expression: rel_expression

0 

At line no: 74 	expression: logic_expression

0 

At line no: 74 	statement: RETURN expression SEMICOLON

return 0 ; 


At line no: 74 	statements: statements statement

int x , y ; 
float z ; 
x = 2 ; 
y = x * 45 ; 
z = x * y / 1.0 * 0.5 ; 
arr [ z ] = x ; 
arr [ x > z ] = y ; 
arr [ y > z * 2.0 ] = z ; 
float some_val ; 
some_val = func ( x , z , y ) ; 
foo = foo ( ) % 2 ; 
foo ( ) ; 
int i , odd , even ; 
odd = 0 ; 
even = 0 ; 
for ( i = 0 ; 
i < 10 ; 
i ++ ) { 
  if ( i % 2 == 0 ) even ++ ; 
  else odd ++ ; 
} 
while ( i > 0 ) { 
  if ( odd > even ) if ( even == i ) cnt -- ; 
  else cnt ++ ; 
  else if ( odd == i ) cnt ++ ; 
  else cnt -- ; 
  i -- ; 
} 
return 0 ; 


 ScopeTable # 1
 0 --> < some_val : ID > < i : ID >
 1 --> < x : ID >
 2 --> < y : ID >
 3 --> < z : ID > < odd : ID > < even : ID >

At line no: 75 	compound_statement: LCURL statements RCURL

{ 
  int x , y ; 
  float z ; 
  x = 2 ; 
  y = x * 45 ; 
  z = x * y / 1.0 * 0.5 ; 
  arr [ z ] = x ; 
  arr [ x > z ] = y ; 
  arr [ y > z * 2.0 ] = z ; 
  float some_val ; 
  some_val = func ( x , z , y ) ; 
  foo = foo ( ) % 2 ; 
  foo ( ) ; 
  int i , odd , even ; 
  odd = 0 ; 
  even = 0 ; 
  for ( i = 0 ; 
  i < 10 ; 
  i ++ ) { 
    if ( i % 2 == 0 ) even ++ ; 
    else odd ++ ; 
  } 
  while ( i > 0 ) { 
    if ( odd > even ) if ( even == i ) cnt -- ; 
    else cnt ++ ; 
    else if ( odd == i ) cnt ++ ; 
    else cnt -- ; 
    i -- ; 
  } 
  return 0 ; 
} 


At line no: 75 	func_definition: type_specifier ID LPAREN parameter_list RPAREN compound_statement

int main ( void ) { 
  int x , y ; 
  float z ; 
  x = 2 ; 
  y = x * 45 ; 
  z = x * y / 1.0 * 0.5 ; 
  arr [ z ] = x ; 
  arr [ x > z ] = y ; 
  arr [ y > z * 2.0 ] = z ; 
  float some_val ; 
  some_val = func ( x , z , y ) ; 
  foo = foo ( ) % 2 ; 
  foo ( ) ; 
  int i , odd , even ; 
  odd = 0 ; 
  even = 0 ; 
  for ( i = 0 ; 
  i < 10 ; 
  i ++ ) { 
    if ( i % 2 == 0 ) even ++ ; 
    else odd ++ ; 
  } 
  while ( i > 0 ) { 
    if ( odd > even ) if ( even == i ) cnt -- ; 
    else cnt ++ ; 
    else if ( odd == i ) cnt ++ ; 
    else cnt -- ; 
    i -- ; 
  } 
  return 0 ; 
} 


At line no: 75 	unit: func_definition

int main ( void ) { 
  int x , y ; 
  float z ; 
  x = 2 ; 
  y = x * 45 ; 
  z = x * y / 1.0 * 0.5 ; 
  arr [ z ] = x ; 
  arr [ x > z ] = y ; 
  arr [ y > z * 2.0 ] = z ; 
  float some_val ; 
  some_val = func ( x , z , y ) ; 
  foo = foo ( ) % 2 ; 
  foo ( ) ; 
  int i , odd , even ; 
  odd = 0 ; 
  even = 0 ; 
  for ( i = 0 ; 
  i < 10 ; 
  i ++ ) { 
    if ( i % 2 == 0 ) even ++ ; 
    else odd ++ ; 
  } 
  while ( i > 0 ) { 
    if ( odd > even ) if ( even == i ) cnt -- ; 
    else cnt ++ ; 
    else if ( odd == i ) cnt ++ ; 
    else cnt -- ; 
    i -- ; 
  } 
  return 0 ; 
} 


At line no: 75 	program: program unit

int bar ( float x ) { 
  if ( x < 0 ) return - x ; 
  return x ; 
} 
void foo ( ) { 
  return bar ; 
} 
int oops ( ) { 
  return 0 ; 
} 
int oops ( int pos ) { 
  int pos ; 
  pos = 5 ; 
  oops = pos * 9 + 2.5 ; 
} 
int func ( int , float , int ) ; 
int func ( int a , int b , int c ) { 
  return a - bar ( b ) + c ; 
} 
int func ( int a , float b , int c ) { 
  return a - bar ( b ) + c ; 
} 
int func ( int p , float r , int q ) { 
  return p - q ; 
} 
int arr [ 100 ] ; 
int main ( void ) { 
  int x , y ; 
  float z ; 
  x = 2 ; 
  y = x * 45 ; 
  z = x * y / 1.0 * 0.5 ; 
  arr [ z ] = x ; 
  arr [ x > z ] = y ; 
  arr [ y > z * 2.0 ] = z ; 
  float some_val ; 
  some_val = func ( x , z , y ) ; 
  foo = foo ( ) % 2 ; 
  foo ( ) ; 
  int i , odd , even ; 
  odd = 0 ; 
  even = 0 ; 
  for ( i = 0 ; 
  i < 10 ; 
  i ++ ) { 
    if ( i % 2 == 0 ) even ++ ; 
    else odd ++ ; 
  } 
  while ( i > 0 ) { 
    if ( odd > even ) if ( even == i ) cnt -- ; 
    else cnt ++ ; 
    else if ( odd == i ) cnt ++ ; 
    else cnt -- ; 
    i -- ; 
  } 
  return 0 ; 
} 


At line no: 75 	start: program

int bar ( float x ) { 
  if ( x < 0 ) return - x ; 
  return x ; 
} 
void foo ( ) { 
  return bar ; 
} 
int oops ( ) { 
  return 0 ; 
} 
int oops ( int pos ) { 
  int pos ; 
  pos = 5 ; 
  oops = pos * 9 + 2.5 ; 
} 
int func ( int , float , int ) ; 
int func ( int a , int b , int c ) { 
  return a - bar ( b ) + c ; 
} 
int func ( int a , float b , int c ) { 
  return a - bar ( b ) + c ; 
} 
int func ( int p , float r , int q ) { 
  return p - q ; 
} 
int arr [ 100 ] ; 
int main ( void ) { 
  int x , y ; 
  float z ; 
  x = 2 ; 
  y = x * 45 ; 
  z = x * y / 1.0 * 0.5 ; 
  arr [ z ] = x ; 
  arr [ x > z ] = y ; 
  arr [ y > z * 2.0 ] = z ; 
  float some_val ; 
  some_val = func ( x , z , y ) ; 
  foo = foo ( ) % 2 ; 
  foo ( ) ; 
  int i , odd , even ; 
  odd = 0 ; 
  even = 0 ; 
  for ( i = 0 ; 
  i < 10 ; 
  i ++ ) { 
    if ( i % 2 == 0 ) even ++ ; 
    else odd ++ ; 
  } 
  while ( i > 0 ) { 
    if ( odd > even ) if ( even == i ) cnt -- ; 
    else cnt ++ ; 
    else if ( odd == i ) cnt ++ ; 
    else cnt -- ; 
    i -- ; 
  } 
  return 0 ; 
} 


 ScopeTable # 0
 1 --> < bar : ID > < oops : ID > < func : ID > < main : ID >
 2 --> < foo : ID >
 3 --> < arr : ID >

